## 一、简介

通过github SecurityLab上的多个CodeQL的使用例子来加深对于CodeQL的理解和学习，以及一个重要的点就是漏洞模式的积累

主要参考kp的写法的模式。

## 二、ChakraCore-bad-overflow-check

### 1.漏洞模式

- 这个例子主要学习如何查找**错误的整数相加溢出检测逻辑**

  > 注意不是检测整数相加溢出

  以下面的这种例子为例

  ```c
  bool checkOverflow(unsigned short x, unsigned short y) {
    // BAD: comparison is always false due to type promotion
    return (x + y < x);  
  }
  ```

  这里相加后的结果其实会由于**整形提升**，相加后的结果会提升为`int`类型，所以这里的加法操作是**始终不会溢出**的。所以这里是没法正常判断是否存在溢出。

- 下面这个例子中：

  ```c
  bool checkOverflow(unsigned short x, unsigned short y) {
    return ((unsigned short)(x + y) < x);  // GOOD: explicit cast
  }
  ```

  这个例子中由于相加后的结果经过了强制类型转换，所以加法的结果可以产生溢出，那么溢出判断逻辑就可以正常工作。

### 2.Query

- 首先我们在编写查询之前，先来理清这个漏洞模式的必要条件。

  1. 首先就是符合 `var1 + var2 <compare> var1` 这个公式的语句

  2. 比较操作符`RelationalOperation`的一侧有一个`AddExpr`，一侧有一个`LocalScopeVariable` var1

  3. 加法操作`AddExpr`内部含有一个`LocalScopeVariable` var1，与上面那个var 1相同

     ```ql
     import cpp
     predicate overflowcheck(LocalScopeVariable var,AddExpr add,RelationalOperation compare){
       //左右两边为一个变量和一个加法语句
       compare.getAnOperand() = var.getAnAccess() and
       compare.getAnOperand() = add and
       add.getAnOperand() = var.getAnAccess()
     
     }
     from LocalScopeVariable var,AddExpr add
     // "_"通配符表示任何数据集
     where overflowcheck(var,add,_)
     select add,"Overflow check on variable of type" + var.getUnderlyingType()
     ```

  4. 操作数 var1 位数必须小于32位

     ```
     import cpp
     /** Matches `var < var + ???`. */
     predicate overflowCheck(LocalScopeVariable var, AddExpr add, RelationalOperation compare){
       /* 当前的relationalOperation，其左右两边分别是一个变量以及一个加法语句 */
       compare.getAnOperand() = var.getAnAccess() and
       compare.getAnOperand() = add and
       /* 同时这个变量还是加法语句中的一个操作数 */
       add.getAnOperand() = var.getAnAccess()
     }
     from LocalScopeVariable var, AddExpr add
     where overflowCheck(var, add, _)    /* 获取可能存在溢出的点 */
       and var.getType().getSize() < 4   /* 当前的操作数大小要小于4字节 */
     select add, "Overflow check on variable of type " + var.getUnderlyingType()
     ```

     

  5. 加法运算的结果不执行强制转换，或者强制转换的大小大于32位

     > 这个条件会使得溢出算法失效，也是漏洞所在

- 最终的QL代码如下：

  ```ql
  import cpp
  
  /** Matches `var < var + ???`. */
  predicate overflowCheck(LocalScopeVariable var, AddExpr add, RelationalOperation compare){
    /* 当前的relationalOperation，其左右两边分别是一个变量以及一个加法语句 */
    compare.getAnOperand() = var.getAnAccess() and
    compare.getAnOperand() = add and
    /* 同时这个变量还是加法语句中的一个操作数 */
    add.getAnOperand() = var.getAnAccess()
  }
  
  from LocalScopeVariable var, AddExpr add
  where overflowCheck(var, add, _)    /* 获取可能存在溢出的点 */
    and var.getType().getSize() < 4   /* 当前的操作数大小要小于4字节 */
    and not add.getConversion+().getType().getSize() < 4 /* 限制加法的位数 >= 32 */
  select add, "Overflow check on variable of type " + var.getUnderlyingType()
  ```

### 总结

这里的主要原因就是整型提升，当位宽小于32位的，就可能会有整型提升的问题，往往因为忘记加上强制类型转换，保证计算前和计算后的类型一致。这里其实还有一种情况就是不一定要位宽小于32位的，大于也行，这样强制转换为更大位数的，这种也会使溢出检测算法失效，但是应该不会有人这么写代码。

## 三、rsyslog_CVE-2018-1000140

### 1.漏洞模式

- 这个例子主要是学习如何查找出`snprintf`函数返回值误用的情况

  ```c
  //int snprintf(char *s,size_t n,const char * format)
  #define BUF_SIZE (32)
  int main(int argc,char *argv[])
  {
      char buffer[BUF_SIZE];
      size_t pos = 0;
      int i;
      for(int i=0;i<argc;i++)
      {
          pos += snprintf(buffer + pos,BUF_SIZE - pos,"%s",argv[i]);
          //BUF_SIZE - pos may overflow
      }
  }
  ```

  这里`snprintf`函数的返回值并不一定是写入的字符数，所以可能导致返回值错误的误用

### 2.Query

- 首先依旧是先列出这个模式的必要条件，即通过上面条件来查找这个漏洞
  1. 首先肯定就是`snprintf`这个函数的`FunctionCall`
  
     ```
     import cpp
     
     from FunctionCall call
     where call.getTarget().getName()="snprintf"
     select call
     ```
  
  2. 只有使用了`snprintf`函数返回值的情况才会存在漏洞
  
     ```
     import cpp
     
     from FunctionCall call
     where call.getTarget().getName()="snprintf"
     and not call instanceof ExprInVoidContext
     select call
     ```
  
  3. 然后就是`snprintf`中存在`%s`格式化字符串
  
     ```
     import cpp
     
     from FunctionCall call
     where call.getTarget().getName()="snprintf"
     and not call instanceof ExprInVoidContext
     and call.getArgument(2).getValue().regexpMatch("(?s).*%s.*")
     select call
     ```
  
  4. `snprintf`函数的返回值被重新复用到`size`参数处
  
     ```
     import cpp
     import semmle.code.cpp.dataflow.TaintTracking
     
     from FunctionCall call, DataFlow::Node source, DataFlow::Node sink
     where call.getTarget().getName() = "snprintf"
     and call.getArgument(2).getValue().regexpMatch("(?s).*%s.*")
     and TaintTracking::localTaint(source, sink)
     and source.asExpr() = call
     and sink.asExpr() = call.getArgument(1)
     select call
     ```
  
- 最终的QL代码如下：

  ```
  import cpp
  import semmle.code.cpp.dataflow.TaintTracking
  
  from FunctionCall call, DataFlow::Node source, DataFlow::Node sink
  where call.getTarget().getName() = "snprintf"
  and call.getArgument(2).getValue().regexpMatch("(?s).*%s.*")
  and TaintTracking::localTaint(source, sink)
  and source.asExpr() = call
  and sink.asExpr() = call.getArgument(1)
  select call
  ```

### 总结

假设`snprintf`函数的fmt中包含了'%s'，则寻找该函数的返回值，是否在后续的`snprintf`的调用中被用到，用到就可能存在漏洞；这里的一种情况就是第一次循环的`snprintf`的返回值，被第二次循环的`snprintf`使用。

## 四、libssh2_eating_error_codes

### 1.漏洞模式

考虑下面一种情况：

```c
int _libssh2_get_c_string(...){ /* ... */}
unsigned int p_len;
if((p_len = _libssh2_get_c_string(&buf, &p)) < 0)
    //...
```

其中，`_libssh2_get_c_string`函数返回一个**带符号整型**，而接受这个返回值的变量`p_len`为**无符号整型**。因此函数产生的error code(-1)将会被忽略。

### 2.Query

- 首先依旧是列出必要条件

  1. 函数返回值为负数，这可能表示error code

     ```
     import cpp
     
     from ReturnStmt ret
     where ret.getExpr().getValue.toInt() < 0
     select ret
     ```

  2. 查找一个函数调用，该函数会调用那些返回负数的函数

     ```
     import cpp
     
     from FunctionCall call, ReturnStmt ret
     where
       ret.getExpr().getValue().toInt() < 0 and
       call.getTarget() = ret.getEnclosingFunction()
     select ret,call
     ```

  3. 函数返回值类型被转换为无符号整型

     ```
     import cpp
     import semmle.code.cpp.dataflow.DataFlow
     
     from ReturnStmt ret,FunctionCall call
     where
      ret.getExpr().getValue().toInt() < 0 and
      call.getTarget() = ret.getEnclosingFunction() and
      call.getFullyConverted().getType().getUnderlyingType().(IntegralType).isUnsigned()
     select call
     ```

     但是这种查询仅能够查询将函数调用的结果立即转换为无符号的情况，下面这种情况就是类型转换不会立即发生，所以无法检测到：

     ```c
     int ret = f();
     unsigned int ret2 = ret;
     ```

  4. 我们使用数据流分析技术，查询从`FunctionCall`流出的数据(返回值)到最近的一个无符号类型转换的路径

     ```
     import cpp
     import semmle.code.cpp.dataflow.DataFlow
     
     from FunctionCall call, ReturnStmt ret, DataFlow::Node source, DataFlow::Node sink
     where
       ret.getExpr().getValue().toInt() < 0 
       and call.getTarget() = ret.getEnclosingFunction() 
       and source.asExpr() = call 
       and sink.asExpr().getFullyConverted().getType().getUnderlyingType().(IntegralType).isUnsigned() 
       and DataFlow::localFlow(source, sink)
     select source, sink
     ```

     到此，我们的查询会有奇怪的问题，因为它包含了所有`sink`为无符号整型的路径，我们需要的是从`signed`到`unsigned`的转换，并且`sink`可能为负数然后转换为`unsigned`。

- 最终的QL代码如下：

  ```
  import cpp
  import semmle.code.cpp.dataflow.DataFlow
  import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
  
  from FunctionCall call, ReturnStmt ret, DataFlow::Node source, DataFlow::Node sink
  where
   ret.getExpr().getValue().toInt() < 0 and
   call.getTarget() = ret.getEnclosingFunction() and
   source.asExpr() = call and
   DataFlow::localFlow(source, sink) and
   sink.asExpr().getFullyConverted().getType().getUnderlyingType().(IntegralType).isUnsigned() and
   lowerBound(sink.asExpr()) < 0
  select source, sink
  ```

### 总结

这种漏洞模式就是有符号转换成了无符号类型，并且`sink`是可以存在负数的情况，那么就溢出了。

