## 实模式

### BIOS

BIOS是输入输出系统，是当我们按下主机键后运行的第一个软件，它的主要工作有：

- 调用检测、初始化硬件功能
- 在内 存中 `0x000～0x3FF` 处建立数据结构，中断向量表 `IVT` 并填写中断例程
- 校验启动盘中位于0盘0道1扇区的内容

实模式下的1MB内存布局如下，其中0～0x9FFFF处是DRAM，即动态随机访问内存，我们所装的物理内存就是DRAM，如DDR、DDR2等。顶部的0xF0000～0xFFFFF，这64KB的内存是ROM。

![image-20200810215713020.png](https://i.loli.net/2020/08/12/cup5JxM96wyLHeY.png)

BIOS是第一个运行的软件，所以没法用其他软件加载它，故需要用硬件对其加载到ROM(0xF0000~0xFFFFF)中，当开机加电后强制将`CS:IP`置为`0xF000:0xFFF0`，实模式段基址需要乘16(左移四位)，故起始地址为0xFFFF0

```
(0xF000 << 4) + 0xFFF0 = 0xFFFF0
```

这个起始地址距离1MB内存只有16字节大小，所以这里肯定不是真正实现BIOS的地方，这里肯定只是一个类似于函数索引表的跳板，跳转到真正执行BIOS的地方。

BIOS最后的工作就是校验启动盘中位于0盘0道1扇区的内容，这里面其实主要校验的是MBR(以逻辑 LBA 方式，扇区从 0 开始编号，若是以物理 CHS 方式， 扇区则从 1 开始编号)，如果此扇区末尾两个字节为0x55和0xaa，BIOS即认定这里为MBR(本身为512字节)，便将其加载到0x7c00处，然后跳转到这个地方继续执行。通常，MBR 的任务是加载某个程序（这个程序一 般是内核加载器，很少有直接加载内核的）到指定位置，并将控制权交给它。

### 第一个mbr

这里用NASM实现一个简单的MBR，功能是在屏幕上打印字符串”1 MBR”，背景色黑色，前景色绿色

> 因为中文格式问题，复制时建议删除中文注释

```
;mbr.S
;主引导程序
; ----------------------------------------------------------
SECTION MBR vstart=0x7c00 ; 起始地址为0x7c00
    mov ax,cs               ; cs寄存器初始化其他寄存器
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00           ;初始化栈指针

;下面功能为清屏，清理其他输出信息，保证我们的输出内容可见+

; -----------------------------------------------------------
; INT 0x10　 功能号:0x06　　功能描述:上卷窗口
; -----------------------------------------------------------
; AH 功能号= 0x06
; AH = 上卷的行数(如果为0，表示全部)
; BH = 上卷行属性
; (CL,CH) = 窗口左上角的(X,Y)位置
; (DL,DH) = 窗口右下角的(X,Y)位置
; 无返回值
    mov ax,0x600
    mov bx,0x700
    mov cx,0                ;左上角:(0，0)
    mov dx,0x184f           ;右下角:(80,25)
                            ; VGA文本模式中,一行只能容纳80个字符,共25行｡
                            ; 下标从0开始,所以0x18=24,0x4f=79
    int 0x10                ;int 0x10

;;;;;;;;;　　下面这三行代码获取光标位置　　;;;;;;;;;
;.get_cursor获取当前光标位置,在光标位置处打印字符｡
    mov ah,3                ; 输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh,0                ; bh寄存器存储的是待获取光标的页号，这里是第0页

    int 0x10                ; 输出 : ch=光标开始行,cl=光标结束行
                            ; dh=光标所在行号,dl=光标所在列号

;;;;;;;;;　　获取光标位置结束　　;;;;;;;;;

;;;;;;;;;　　打印字符串　　;;;;;;;;;
    ;还是用10h中断,不过这次调用13号子功能打印字符串
    mov ax,message
    mov bp,ax               ; es:bp 为串首地址,es此时同cs一致,
                            ; 开头时已经为sreg初始化

   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    mov cx,5               ; cx 为串长度,不包括结束符0的字符个数
    mov ax,0x1301          ; 子功能号13显示字符及属性,要存入ah寄存器,
                            ; al设置写字符方式 al=01: 显示字符串,光标跟随移动
    mov bx,0x2             ; bh存储要显示的页号,此处是第0页,
                            ; bl中是字符属性,属性黑底绿字(bl = 02h)
    int 0x10                ; 执行BIOS 0x10 号中断
;;;;;;;;;　　打字字符串结束　　;;;;;;;;;
                            ; $为eip地址,$$为本section的起始地址
    jmp $                   ; 使程序无限循环,相当于jmp eip

    message db "1 MBR"      ; 打印的字符串
    times 510-($-$$) db 0      ; 用0填充本扇区空余的字节数,$-$$即为本行到本section的偏移
                            ; 510是512为了腾出2字节存放0x55和0xaa魔数
                            ; 也就是覆盖除了最后两字节和上面已经写了的字节
    db 0x55,0xaa
```

使用`sudo nasm -o mbr.bin mbr.S`编译生成`mbr.bin`文件，然后用dd命令将其写入我们镜像中的第0行，512字节大小，也就是写入一开始BIOS执行的MBR

```
dd if=/home/qdl/bochs-2.6.2/bin/mbr/mbr.bin of=/home/qdl/bochs-2.6.2/bin/hd60M.img bs=512 count=1  conv=notrunc 
```

执行上面命令后

```
记录了 1+0 的读入 
记录了 1+0 的写出 
512 字节（512 B）已复制，0.313312 秒，1.6 KB/秒 
```

再次运行`sudo ./bochs -f bochsrc.disk`即可显示出我们写的内容，断下的时候输入c即可运行

![image-20200810214828558.png](https://i.loli.net/2020/08/12/o1YRPmDh82bruvl.png)



