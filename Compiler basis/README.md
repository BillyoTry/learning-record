## CS143课程学习

本次课程使用斯坦福的cs143及相关Lab

- #### lexer ——词法分析

  - 借用`flex`工具来生成`lexer`词法分析器。
  - 在flex脚本中，我们通过编写正则表达式来匹配字符串，返回一个个的`token`。
  - 生成的`lexer`词法分析器可以通过正则语法将读入内容转化为`token`。
  - 词法分析中过滤的错误，例如：
    1. 字符串过长(超出1025)
    2. 引号、注释符未闭合
    3. 未在规定范围内的字符

  正则表达式的规则非常简单易懂，但是正则表达式并不能直接用来解析所输入的字符串，这需要借助一种称为**有穷自动机**的模型。

  > 注：lexer的核心就是有穷自动机

  有穷自动机包含一个有限状态的集合以及从一个状态到另一个状态的转换，并且状态必须包含**一个起始状态**以及**至少一个接受状态**。有穷自动机就是一个有向图，状态就相当于图的节点，而状态转换就是图的边，更简单的理解就是图的边相当于我们读入的字符串。

  有穷自动机处理字符串流程：

  1. 初始情况下，自动机处于**初始状态**
  2. 读取字符，这是自动机会查询**当前状态**(图的节点)以及**读入的字符**(边)来跳转到下一状态
  3. 重复第二步，直至字符串全部输入
  4. 字符串全部输入后，如果此时的状态是**接受状态**(accept)，就说该自动机接受了这一字符串

  有穷自动机又分为两种：

  1. 确定性有穷自动机(DFA)。从每一个状态只能发出一条具有某个符号的边，不存在ε（表示空）符号的边。
  2. 非确定性有穷自动机(NFA)。允许从一个状态发出多条具有相同符号的边，甚至允许发出标有ε（表示空）符号的边，即NFA可以不输入任何字符就自动沿ε边转换到下一个状态。

  <a href='https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/'>flex生成代码分析</a>

- #### parser——语法分析

  语法分析使用bison工具，bison使用左递归也就是自底向上的分析方法，与flex类似都是**自动机**。

  语法分析的主要工作是构建一个AST抽象语法树

  <a href='https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/'>bison生成代码分析</a>

- #### semant——语义分析

  lexer在输入内部检测到非法token，而parser在输入内部检测格式不正确的解析树。 语义分析是编译器捕获错误的最后一个“前端”阶段。 这是必要的，因为存在解析器和词法分析器无法捕获的错误，并且某些语言构造不是上下文无关的。 作为一种典型的静态类型检查的面向对象语言，cool需要其语义分析器进行的检查包括但不限于：

  - 所有标识符均已声明
  - 类型检查（主要功能）
  - 继承关系
  - 类仅定义一次
  - 类中的方法仅定义一次
  - 保留标识符不被滥用

  未完

- #### cgen——代码生成

//todo 